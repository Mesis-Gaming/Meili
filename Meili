local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera

-- Configuration
getgenv().SilentEnabled = true
local Config = {
    Manipulation = {
        Enabled = true,
        Angles = 1,
        Radius = 6,
        Direction = "Normal",
        Vector = Vector3.new(0, 0, 0),
    },
    FOVCircleEnabled = true,
    SnaplineEnabled = true,
}

-- FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.Radius = 25
FOVCircle.Color = Color3.fromRGB(45, 116, 202)
FOVCircle.Visible = Config.FOVCircleEnabled

-- Snap Line
local Line = Drawing.new("Line")
Line.Color = Color3.fromRGB(255, 255, 255)
Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
Line.Thickness = 1
Line.Visible = Config.SnaplineEnabled

-- Toggle State
local TogglesEnabled = true

-- Toggle Function
local function toggleFeatures()
    TogglesEnabled = not TogglesEnabled
    Config.FOVCircleEnabled = TogglesEnabled
    Config.SnaplineEnabled = TogglesEnabled
    Config.Manipulation.Enabled = TogglesEnabled
    getgenv().SilentEnabled = TogglesEnabled

    FOVCircle.Visible = Config.FOVCircleEnabled
    Line.Visible = Config.SnaplineEnabled
    print("Toggles are now " .. (TogglesEnabled and "Enabled" or "Disabled"))
end

-- Input Handler
UserInputService.InputBegan:Connect(function(input, isProcessed)
    if isProcessed then return end
    if input.KeyCode == Enum.KeyCode.B then
        toggleFeatures()
    end
end)

-- Update Snap Line
local function updateSnapline(Target)
    if Target and Target:FindFirstChild("Head") and Config.SnaplineEnabled then
        local headPos, onScreen = Camera:WorldToViewportPoint(Target.Head.Position)
        Line.Visible = onScreen

        if onScreen then
            Line.To = Vector2.new(headPos.X, headPos.Y)
        else
            Line.Visible = false
        end
    else
        Line.Visible = false
    end
end

-- Target Acquisition Logic (Replace with your own logic)
local function GetPlayer()
    local closest, closestMagnitude = nil, math.huge
    for _, v in ipairs(workspace.Players:GetChildren()) do
        if v:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(v.Head.Position)
            local distance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude

            if onScreen and distance < FOVCircle.Radius and distance < closestMagnitude then
                closest = v
                closestMagnitude = distance
            end
        end
    end
    return closest
end

-- Silent Aim Prediction
local function Predict(Target, Velocity)
    local Distance = (Target.Position - Camera.CFrame.Position).Magnitude
    local TimeToHit = Distance / 1000 -- Assuming projectile speed of 1000
    local Prediction = Target.Position + (Velocity * TimeToHit)
    return Prediction
end

-- Run Snap Line and Manipulation Updates
RunService.RenderStepped:Connect(function()
    if not TogglesEnabled then return end
    local Target = GetPlayer()

    if Target then
        -- Update Snapline
        updateSnapline(Target)

        -- Update Manipulation
        if Config.Manipulation.Enabled then
            local predictedPosition = Predict(Target.Head, Vector3.new(0, 0, 0)) -- Replace with velocity logic if needed
            Config.Manipulation.Vector = predictedPosition
        end
    end
end)
